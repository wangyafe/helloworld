1.控制锁的粒度（也即控制锁的时间）
2.互斥锁synchronized（单机版）
3.分布式锁：1.redis 2.zk 3.数据库分布式锁
  3.1 非原子性（加锁操作和后面的设置超时时间）
  3.2 忘了释放锁
  3.3 释放的别人的锁（1.大事务锁失效 2.其他线程加锁成功 3.释放别人的锁）（1.用requestId标识是不是本线程的锁 2.lua脚本 保证查和删是原子性）
  3.4 大量失败请求（1.互斥性只有一个成功 2.失败的线程部分场景需要的结果是成功 比如创建目录）使用自旋锁
  3.5 锁重入（1.锁名和requestId值都存在（1.重入数加一 2.重新设置过期时间） 2.锁名和requestId值存在，则重入锁减1 重新设置过期时间） 递归中使用分布式锁
  3.6 锁分段（1.多线程竞争一把锁变为竞争多把锁 2.秒杀场景锁住的是库存分区）
  3.7 锁超时问题（1.达到了超时时间，业务代码还没执行完 2.设置总的超时时间）
  3.8 主从复制的问题（加锁和同步slave不是原子性的） （1.redisson框架提供了一个专门的类：RedissonRedLock（红锁）使用了Redlock算法）
    1.搭建几套相互独立的redis环境 2.环境都有一个redisson node节点 3.redisson node节点组成了RedissonRedLock 4.半同步node节点（设置过期时间）
 4.聊聊redis分布式锁的8大坑 https://developer.aliyun.com/article/854283#slide-5
  4.1 数据一致性：CP类型的分布式锁，比如：zookeeper，它是基于磁盘的，性能可能没那么好，但数据一般不会丢
  4.2 数据高可用性：AP类型的分布式锁，比如：redis，它是基于内存的，性能比较好，但有丢失数据的风险
