1.分代回收
  1.1 回收的是内存模型中的java堆 1.2 java堆又分为新生代（复制算法）、老年代（标记整理） 1.3 新生代又分为eden tosurvivor From Survivor 默认8：1：1
  1.4 分代垃圾回收器：新生代收集器：Serial、ParNew、Parallel Scavenge 老年代收集器：CMS、Serial Old、Parallel Old
  1.5 整堆垃圾回收器：G1
2.垃圾回收器实现
1.serial:单线程
2.parNew：多线程
3.paraller: 吞吐量优先级大于停顿时间
4.GMC（Concurrent Mark-Sweep 使用标记清除算法）:停顿时间优先级大于吞吐量
3.Yong Gc（新生代回收）比full GC（老年代回收）快原因：
  3.1 年轻代比老年代存活的对象要少很多;
  3.2 老年代除了标记清除之外, 还要进行内存碎片的清理, 另外还有可能发生Concurrent Mode Failure;
4.1.标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。
  2.标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
  3.复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半
