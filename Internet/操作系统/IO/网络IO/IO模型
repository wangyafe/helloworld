1.网络包经过三次复制 1.网卡（设备） 2.设备控制器 3.内核区 4.用户区       
2. 1.同步（同一个线程） 2.异步（不同线程）3.阻塞（数据未准备就绪 线程被挂起） 4.非阻塞（数据准备就绪 直接返回）
3.网络IO模型 1.同步阻塞IO(OS提供的read函数是阻塞的) 2.同步非阻塞（OS提供非阻塞read函数 但内核拷贝到用户空间这一步，用户线程还是会被阻塞的） 3.IO多路复用 4.信号驱动式IO 
  5.异步IO(AIO 数据拷贝到用户区再通知用户线程)
   3.1 多路指多个连接 复用指一个线程监控连接 查询哪些数据是可以read 通知给read线程
   3.2 多路复用有三个函数1.select（批量查询文件描述符状态 内核轮询） 2.poll(解除select只能监听1024个文件描述符的限制) 3.epoll(解决select三大问题)
      3.3 1.内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可
          2.内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒
          3.内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合
   5.1 Linux未完全实现AIO 2.tomcat底层实现是用epoll模拟实现的AIO 3.windows真正实现了AIO 但项目部署在linux
   5.2 主流还是 I/O 多路复用(1.AIO未彻底实现 2.信号驱动式IO TCP协议的socket产生信号相同 无法区分哪个是数据准备就绪)
4.图解 | 原来这就是 IO 多路复用 https://zhuanlan.zhihu.com/p/360878783
5.让我们，从头到尾，通透I/O模型 https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&mid=2247493642&idx=1&sn=113839708c9a0acf9fb8e4a9f5fc02bc&chksm=c1618573f6160c650b0dd2e1dede03f8bdbca06668697f756e8f2262d86d6b3c15622ecc0e68&scene=178&cur_album_id=2087617432768086020#rd
